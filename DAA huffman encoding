#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
using namespace std;

// Structure to represent each node in Huffman Tree
struct Node {
    char ch;
    int freq;
    Node* left;
    Node* right;

    Node(char character, int frequency) {
        ch = character;
        freq = frequency;
        left = right = nullptr;
    }
};

// Custom comparator for priority queue (min-heap)
struct Compare {
    bool operator()(Node* a, Node* b) {
        return a->freq > b->freq;
    }
};

// Recursive function to generate Huffman codes
void generateCodes(Node* root, string code, unordered_map<char, string>& huffMap) {
    if (!root) return;

    // If leaf node (character node)
    if (!root->left && !root->right) {
        huffMap[root->ch] = code;
    }

    // Recurse left → append "0"
    generateCodes(root->left, code + "0", huffMap);
    // Recurse right → append "1"
    generateCodes(root->right, code + "1", huffMap);
}

// Huffman Encoding function
vector<string> huffEnco(vector<char>& chars, vector<int>& freqs) {
    priority_queue<Node*, vector<Node*>, Compare> minHeap;

    // Step 1: Create a leaf node for each character and push it into the heap
    for (int i = 0; i < chars.size(); ++i) {
        minHeap.push(new Node(chars[i], freqs[i]));
    }

    // Step 2: Build the Huffman Tree
    while (minHeap.size() > 1) {
        Node* left = minHeap.top(); 
        minHeap.pop();
        Node* right = minHeap.top(); 
        minHeap.pop();

        Node* merged = new Node('\0', left->freq + right->freq);
        merged->left = left;
        merged->right = right;

        minHeap.push(merged);
    }

    // Step 3: Generate Huffman Codes
    Node* root = minHeap.top();
    unordered_map<char, string> huffMap;
    generateCodes(root, "", huffMap);

    // Step 4: Return the Huffman codes in the same order as input
    vector<string> result;
    for (char c : chars) {
        result.push_back(huffMap[c]);
    }

    return result;
}

// Main Function
int main() {
    int n;
    cout << "Enter number of characters: ";
    cin >> n;

    vector<char> characters(n);
    vector<int> frequencies(n);

    cout << "Enter characters:\n";
    for (int i = 0; i < n; ++i) {
        cin >> characters[i];
    }

    cout << "Enter corresponding frequencies:\n";
    for (int i = 0; i < n; ++i) {
        cin >> frequencies[i];
    }

    // Call Huffman Encoding
    vector<string> huffmanCodes = huffEnco(characters, frequencies);

    // Display the result
    cout << "\nCharacter\tFrequency\tHuffman Code\n";
    cout << "--------------------------------------------\n";
    for (int i = 0; i < n; i++) {
        cout << characters[i] << "\t\t" << frequencies[i] << "\t\t" << huffmanCodes[i] << endl;
    }

    return 0;
}


//vector<char> characters = {'a', 'b', 'c', 'd', 'e', 'f'};
  //  vector<int> frequencies = {5, 9, 12, 13, 16, 45};
 Type                 | Complexity | Explanation                                                  |
| -------------------- | ---------- | ------------------------------------------------------------ |
| **Time Complexity**  | O(n log n) | Building heap and combining nodes (n = number of characters) |
| **Space Complexity** | O(n)       | Storing tree nodes, frequency map, and Huffman codes         |
